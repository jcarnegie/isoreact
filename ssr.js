var uuid  = require("uuid");
var react = require("react");
var r     = require("ramda");
var ReactInstanceHandles = require("react/lib/ReactInstanceHandles");
var ReactMarkupChecksum = require("react/lib/ReactMarkupChecksum");
var ReactServerRenderingTransaction = require("react/lib/ReactServerRenderingTransaction");
var instantiateReactComponent = require("react/lib/instantiateReactComponent");

var contexts = {
    SERVER_BEFORE_ASYNC: "server-before-async",
    SERVER_AFTER_ASYNC:  "server-after-async",
    CLIENT_PAGE_LOAD:    "client-page-load",
    CLIENT_PAGE_LOADED:  "client-page-loaded"
};

var containers = {};

var _renderId = function() {
    return uuid.v1();
};

// Todo: generate a guid instead
var mixin = {
    contextTypes: { renderState: react.PropTypes.object },

    _elementId: function() {
        return this._rootNodeID + '__' + this._mountDepth;
    },

    getInitialState: function() {
        var elementId   = this._elementId();
        var renderState = this.context.renderState;
        var context     = renderState.context;
        var states      = renderState.states;

        if (context === contexts.SERVER_BEFORE_ASYNC) {
            if (this.getInitialStateAsync) {
                // let the framework know we're starting an async call
                renderState.startAsyncCall();

                this.getInitialStateAsync(function(state) {
                    // save the state
                    states[elementId] = state;
                    // let the renderer know we're done
                    renderState.completeAsyncCall();
                });
            }
            return {};
        } else if (context === contexts.SERVER_AFTER_ASYNC) {
            return states[elementId] || {};
        } else if (context === contexts.CLIENT_PAGE_LOAD) {
            return window._$reactSSR.states[elementId];
        } else {
            console.trace(this.displayName + ": Unknown context!");
            // throw new Error("Unknown context");
        }
    },

    /**
     *
     */
    componentDidMount: function() {
        var renderState = this.context.renderState;
        if (renderState.context !== contexts.CLIENT_PAGE_LOADED) return;

        if (this.getInitialStateAsync) {
            this.getInitialStateAsync(function(state) {
                if ( !this.isMounted() ) return;
                this.setState(state);
            }.bind(this));
        }
    }
};

/**
 * Object for tracking the state of the render. Necessary on the server side
 * to track componenent states generated by multiple requests.
 */
var createRenderState = function(renderId, txId, done) {
    return {
        // unique id for this render
        renderId: renderId,

        // render transaction id. keep track of it here for the 2nd render
        // since it's used to generate ids for each component and needs to
        // remain the same between 1st and 2nd render
        txId: txId,

        // callback to signal all async calls complete
        done: done,

        // container component
        container: function() {
            return containers[this.renderId];
        },

        // when / where is the render executing?
        context: contexts.SERVER_BEFORE_ASYNC,

        // map of component states
        states: {},

        // how many async calls have been made?
        asyncCallsCount: 0,

        // how many async calls outstanding? used to know when we're complete
        asyncOutstandingCount: 0,

        // track the start of an async call
        startAsyncCall: function() {
            ++this.asyncCallsCount;
            ++this.asyncOutstandingCount;
        },

        // track the completion of an async call. if all 
        completeAsyncCall: function() {
            if (--this.asyncOutstandingCount === 0) {
                try {
                    // async is done, do the 2nd render so markup reflects async state
                    this.context = contexts.SERVER_AFTER_ASYNC;
                    var transaction = ReactServerRenderingTransaction.getPooled(false);
                    var markup = transaction.perform(function() {
                        var componentInstance = instantiateReactComponent(this.container(), null);
                        var markup = componentInstance.mountComponent(this.txId, transaction, 0);
                        return ReactMarkupChecksum.addChecksumToMarkup(markup);
                    }.bind(this), null);
                    this.done(markup, r.cloneObj(this.states));
                } finally {
                    ReactServerRenderingTransaction.release(transaction);
                }
            }
        }
    };
};

/**
 *
 */
var renderToString = function(element, done) {
    var transaction;

    try {
        var txId = ReactInstanceHandles.createReactRootID();

        var renderId = _renderId();

        // setup state for this render
        var renderState = createRenderState(renderId, txId, done);

        // We need this to set the context to be passed down to all of the
        // components in the hierarchy
        var container = react.withContext({ renderState: renderState }, function() {
            return element();
        });

        containers[renderId] = container;

        // mount the component so that react generates the markup
        // DANGER! this is taken from the React renderToString source
        // it'll need to be tested against all future versions of React
        transaction = ReactServerRenderingTransaction.getPooled(false);
        transaction.perform(function() {
            var componentInstance = instantiateReactComponent(container, null);
            var markup = componentInstance.mountComponent(txId, transaction, 0);

            // handle case where no async calls are made
            if (renderState.asyncCallsCount === 0) {
                done("", {});
            }

        }, null);
    } finally {
        ReactServerRenderingTransaction.release(transaction);
    }
};

module.exports = {
    renderToString: renderToString,
    mixin:          mixin
}