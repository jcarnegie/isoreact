var uuid  = require("uuid");
var react = require("react");
var r     = require("ramda");
var ReactInstanceHandles = require("react/lib/ReactInstanceHandles");
var ReactMarkupChecksum = require("react/lib/ReactMarkupChecksum");
var ReactServerRenderingTransaction = require("react/lib/ReactServerRenderingTransaction");
var instantiateReactComponent = require("react/lib/instantiateReactComponent");

var contexts = {
    SERVER_BEFORE_ASYNC: "server-before-async",
    SERVER_AFTER_ASYNC:  "server-after-async",
    CLIENT_PAGE_LOAD:    "client-page-load",
    CLIENT_PAGE_LOADED:  "client-page-loaded"
};

var containers = {};

var _renderId = function() {
    return uuid.v1();
};

var renderToStringInternal = function(txId, container) {
    try {
        // mount the component so that react generates the markup
        // DANGER! this is taken from the React renderToString source
        // it'll need to be tested against all future versions of React
        transaction = ReactServerRenderingTransaction.getPooled(false);

        // this returns the rendered markup
        return transaction.perform(function() {
            var componentInstance = instantiateReactComponent(container, null);
            var markup = componentInstance.mountComponent(txId, transaction, 0);
            return markup;
        }, null);
    } finally {
        ReactServerRenderingTransaction.release(transaction);
    }
}

/**
 * Object for tracking the state of the render. Necessary on the server side
 * to track componenent states generated by multiple requests.
 */
var createRenderState = function(renderId, txId, done) {
    return {
        // unique id for this render
        renderId: renderId,

        // render transaction id. keep track of it here for the 2nd render
        // since it's used to generate ids for each component and needs to
        // remain the same between 1st and 2nd render
        txId: txId,

        // callback to signal all async calls complete
        done: done,

        // container component
        container: function() {
            return containers[this.renderId];
        },

        // when / where is the render executing?
        context: contexts.SERVER_BEFORE_ASYNC,

        // map of component states
        states: {},

        // how many async calls have been made?
        asyncCallsCount: 0,

        // how many async calls outstanding? used to know when we're complete
        asyncOutstandingCount: 0,

        // track the start of an async call
        startAsyncCall: function() {
            ++this.asyncCallsCount;
            ++this.asyncOutstandingCount;
        },

        // track the completion of an async call. if all 
        completeAsyncCall: function() {
            if (--this.asyncOutstandingCount === 0) {
                // async is done, do the 2nd render so markup reflects async state
                this.context = contexts.SERVER_AFTER_ASYNC;
                var markup = renderToStringInternal(this.txId, this.container());
                this.done(markup, r.cloneObj(this.states));
            }
        }
    };
};

/**
 *
 */
var renderToString = function(element, done) {
    var transaction;

    var txId = ReactInstanceHandles.createReactRootID();

    var renderId = _renderId();

    // setup state for this render
    var renderState = createRenderState(renderId, txId, done);

    // We need this to set the context to be passed down to all of the
    // components in the hierarchy
    var container = react.withContext({ renderState: renderState }, function() {
        return element();
    });

    containers[renderId] = container;

    var markup = renderToStringInternal(txId, container);

    // handle case where no async calls are made
    if (renderState.asyncCallsCount === 0) {
        done(markup, {});
    }      
};

/**
 * Make an asynchronous call to get the state of a component.
 */
var async = function(fn) {
    return function() {
        var elementId   = this._elementId();
        var renderState = this.context.renderState;
        var context     = renderState.context;
        var states      = renderState.states;

        if (context === contexts.SERVER_BEFORE_ASYNC) {
            // let the framework know we're starting an async call
            renderState.startAsyncCall();

            // this.getInitialStateAsync(function(state) {
            return fn(function(state) {
                // save the state
                states[elementId] = state;
                // let the renderer know we're done
                renderState.completeAsyncCall();
            });
        } else if (context === contexts.SERVER_AFTER_ASYNC) {
            return states[elementId] || {};
        } else if (context === contexts.CLIENT_PAGE_LOAD) {
            return window._$reactSSR.states[elementId];
        } else {
            console.trace(this.displayName + ": Unknown context!");
            // throw new Error("Unknown context");
        }
    }
};

var mixin = {
    contextTypes: { renderState: react.PropTypes.object },

    _elementId: function() {
        return this._rootNodeID + '__' + this._mountDepth;
    },

    /**
     *
     */
    componentDidMount: function() {
        var renderState = this.context.renderState;
        if (renderState.context !== contexts.CLIENT_PAGE_LOADED) return;

        if (this.getInitialStateAsync) {
            this.getInitialStateAsync(function(state) {
                if ( !this.isMounted() ) return;
                this.setState(state);
            }.bind(this));
        }
    }
};

module.exports = {
    async:          async,
    mixin:          mixin,
    renderToString: renderToString
};